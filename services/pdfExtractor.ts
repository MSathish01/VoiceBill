import * as pdfjsLib from 'pdfjs-dist';
import { BillItem, UserDetails } from '../types';
import { v4 as uuidv4 } from 'uuid';

// Configure PDF.js worker
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://unpkg.com/pdfjs-dist@5.4.530/build/pdf.worker.min.mjs';

/**
 * Interface for embedded PDF data (must match pdfGeneratorV2.ts)
 */
interface EmbeddedPDFData {
  version: string;
  items: BillItem[];
  customer: UserDetails;
  grandTotal: number;
  language: 'en' | 'ta';
  generatedAt: string;
}

/**
 * Result of PDF extraction
 */
export interface PDFExtractionResult {
  items: BillItem[];
  customer?: UserDetails;
  grandTotal?: number;
  isVoiceBillPDF: boolean;
}

/**
 * Decode Base64 to JSON object (handles UTF-8/Tamil characters)
 */
const decodeBase64ToData = (base64String: string): EmbeddedPDFData | null => {
  try {
    // Decode base64 to binary string
    const binaryString = atob(base64String);
    
    // Convert binary string to Uint8Array
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    
    // Use TextDecoder for proper UTF-8 handling (Tamil characters)
    const decoder = new TextDecoder('utf-8');
    const jsonString = decoder.decode(bytes);
    
    // Parse JSON
    const data = JSON.parse(jsonString) as EmbeddedPDFData;
    return data;
  } catch (error) {
    console.error('Failed to decode Base64 data:', error);
    return null;
  }
};

/**
 * Extract text content from a PDF file using pdfjs-dist
 */
const extractTextFromPDF = async (file: File): Promise<string> => {
  try {
    const arrayBuffer = await file.arrayBuffer();
    const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
    const pdf = await loadingTask.promise;
    
    let fullText = '';
    
    // Extract text from all pages
    for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
      const page = await pdf.getPage(pageNum);
      const textContent = await page.getTextContent();
      
      // Join all text items
      const pageText = textContent.items
        .map((item: any) => item.str)
        .join('');
      
      fullText += pageText;
    }
    
    console.log('Extracted raw text length:', fullText.length);
    return fullText;
  } catch (error) {
    console.error('PDF text extraction error:', error);
    throw new Error(`Failed to extract text from PDF: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
};

/**
 * Find and parse VoiceBill JSON data from extracted text
 */
const findVoiceBillData = (text: string): EmbeddedPDFData | null => {
  // Look for our markers
  const startMarker = '<!--VOICEBILL_JSON_START-->';
  const endMarker = '<!--VOICEBILL_JSON_END-->';
  
  const startIndex = text.indexOf(startMarker);
  const endIndex = text.indexOf(endMarker);
  
  if (startIndex === -1 || endIndex === -1 || startIndex >= endIndex) {
    console.log('VoiceBill markers not found in PDF');
    return null;
  }
  
  // Extract the Base64 data between markers
  const base64Data = text.substring(startIndex + startMarker.length, endIndex);
  
  console.log('Found Base64 data, length:', base64Data.length);
  
  // Decode and parse
  const data = decodeBase64ToData(base64Data);
  
  if (data) {
    console.log('Successfully decoded VoiceBill data:', {
      version: data.version,
      itemCount: data.items.length,
      customer: data.customer?.name
    });
  }
  
  return data;
};

/**
 * Fallback: Parse items from text using pattern matching
 * Used for PDFs not generated by VoiceBill
 */
const parseItemsFromTextFallback = (text: string): BillItem[] => {
  const items: BillItem[] = [];
  
  // Try to find table-like patterns
  // Pattern: number | text | quantity | rate | total
  const itemPattern = /(\d+)\s*[|.]\s*([^|]+?)\s*[|]\s*(\d+(?:\.\d+)?\s*(?:kg|g|ltr|ml|pcs)?)\s*[|]\s*(\d+(?:\.\d+)?)\s*[|]\s*(\d+(?:\.\d+)?)/gi;
  
  let match;
  while ((match = itemPattern.exec(text)) !== null) {
    const name = match[2].trim();
    const quantity = match[3].trim();
    const rate = parseFloat(match[4]) || 0;
    const total = parseFloat(match[5]) || 0;
    
    if (name && name.length > 1) {
      items.push({
        id: uuidv4(),
        name,
        quantity: quantity || '1',
        rate,
        total
      });
    }
  }
  
  return items;
};

/**
 * Main function to extract bill items from an uploaded PDF
 */
export const extractItemsFromPDF = async (
  file: File, 
  options?: { 
    tryOcr?: boolean; 
    onProgress?: (msg: string) => void 
  }
): Promise<BillItem[]> => {
  const { onProgress } = options || {};
  
  try {
    onProgress?.('Extracting text from PDF...');
    
    // Extract all text from PDF
    const extractedText = await extractTextFromPDF(file);
    
    if (!extractedText || extractedText.trim().length === 0) {
      throw new Error('No text content found in PDF');
    }
    
    onProgress?.('Searching for VoiceBill data...');
    
    // Try to find embedded VoiceBill JSON data
    const voiceBillData = findVoiceBillData(extractedText);
    
    if (voiceBillData && voiceBillData.items && voiceBillData.items.length > 0) {
      onProgress?.(`Found ${voiceBillData.items.length} items from VoiceBill PDF`);
      
      // Return items with new UUIDs to avoid conflicts
      return voiceBillData.items.map(item => ({
        ...item,
        id: uuidv4() // Generate new ID for imported items
      }));
    }
    
    // Fallback: Try pattern-based extraction
    onProgress?.('VoiceBill data not found, trying pattern matching...');
    
    const fallbackItems = parseItemsFromTextFallback(extractedText);
    
    if (fallbackItems.length > 0) {
      onProgress?.(`Pattern matching found ${fallbackItems.length} items`);
      return fallbackItems;
    }
    
    // No items found
    throw new Error('No items found in PDF. This PDF may not contain extractable bill data.');
    
  } catch (error) {
    console.error('PDF extraction error:', error);
    throw error;
  }
};

/**
 * Extended extraction that also returns customer details
 */
export const extractFullDataFromPDF = async (
  file: File,
  onProgress?: (msg: string) => void
): Promise<PDFExtractionResult> => {
  try {
    onProgress?.('Extracting text from PDF...');
    
    const extractedText = await extractTextFromPDF(file);
    
    if (!extractedText || extractedText.trim().length === 0) {
      throw new Error('No text content found in PDF');
    }
    
    onProgress?.('Searching for VoiceBill data...');
    
    const voiceBillData = findVoiceBillData(extractedText);
    
    if (voiceBillData) {
      return {
        items: voiceBillData.items.map(item => ({
          ...item,
          id: uuidv4()
        })),
        customer: voiceBillData.customer,
        grandTotal: voiceBillData.grandTotal,
        isVoiceBillPDF: true
      };
    }
    
    // Fallback
    const fallbackItems = parseItemsFromTextFallback(extractedText);
    
    return {
      items: fallbackItems,
      isVoiceBillPDF: false
    };
    
  } catch (error) {
    console.error('PDF extraction error:', error);
    throw error;
  }
};
